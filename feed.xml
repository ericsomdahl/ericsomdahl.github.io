<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://ericsomdahl.github.io' rel='self' type='application/rss+xml'/>
<generator>
clj-rss
</generator>
<title>
(defthoughts)
</title>
<link>
http://ericsomdahl.github.io
</link>
<description>
Pondering the ponderables
</description>
<lastBuildDate>
Tue, 03 Mar 2015 22:47:05 -0500
</lastBuildDate>
<author>
Eric Somdahl
</author>
<item>
<guid>
http://ericsomdahl.github.io/posts/2015-03-01-Fifty-four.html
</guid>
<link>
http://ericsomdahl.github.io/posts/2015-03-01-Fifty-four.html
</link>
<title>
Longest Increasing Subsequence
</title>
<description>
&lt;p&gt;&lt;a href='http://www.4clojure.com'&gt;4clojure&lt;/a&gt; is an awesome resource -- I have been having a lot of fun working at these problems.  I am now tackling my first &quot;hard&quot; level problem, &lt;a href='http://www.4clojure.com/problem/53'&gt;Longest Increasing Sub-Seq&lt;/a&gt;.  I have been (mostly) good about not searching for solutions or code so far.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Given a vector of integers, find the longest consecutive sub-sequence of increasing numbers. If two sub-sequences have the same length, use the one that occurs first. An increasing sub-sequence must have a length of 2 or greater to qualify. &lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;a name=&quot;plan&amp;#95;of&amp;#95;attack&quot;&gt;&lt;/a&gt;plan of attack&lt;/h3&gt;My (hopefully idiomatic) approach to the problem is&lt;ol&gt;&lt;li&gt;Create a sequence producer-fn that takes the input and outputs all of the possible sequences therein&lt;/li&gt;&lt;li&gt;filter the sequences for length &gt;= 2&lt;/li&gt;&lt;li&gt;Filter that list for ascending sequences&lt;/li&gt;&lt;li&gt;Sort that list by length, grab the first&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;a name=&quot;the&amp;#95;easy&amp;#95;bits&quot;&gt;&lt;/a&gt;the easy bits&lt;/h3&gt;Filtering the list for ascending sequences is straightforward.&lt;pre&gt;&lt;code&gt;&amp;#40;apply &amp;lt; '&amp;#40;1 2 3&amp;#41;&amp;#41; ;;; true
&amp;#40;apply &amp;lt; '&amp;#40;1 3 2&amp;#41;&amp;#41; ;;; false
&lt;/code&gt;&lt;/pre&gt;And filtering/sorting by count are trivial.&lt;h3&gt;&lt;a name=&quot;the&amp;#95;tricky&amp;#95;part&quot;&gt;&lt;/a&gt;the tricky part&lt;/h3&gt;How to structure this producer function?  I will use a multiple-arity function here.  The first arity, taking a single argument, is simply the entry point.The single argument will be the starting sequence.  It will immediately call to the other arity.&lt;p&gt;The second arity will take 2 arguments&lt;ol&gt;&lt;li&gt;the sequence&lt;/li&gt;&lt;li&gt;a number of elements to take&lt;/li&gt;&lt;/ol&gt;Recursive calls incrementing the second argument appropriately will give us all permutation of sequences from the original.&lt;ol&gt;&lt;li&gt;Start with a take value of 1&lt;/li&gt;&lt;li&gt;Each call increment the take value&lt;/li&gt;&lt;li&gt;When the the take value exceeds the length of the sequence, reset the take value to 1 and take the tail of the sequence for the next call&lt;/li&gt;&lt;li&gt;When the sequence is empty?, we have reached the base case.&lt;/li&gt;&lt;/ol&gt;To that end, I came up with this for generating the sequence:&lt;pre&gt;&lt;code&gt;&amp;#40;fn gen-seq
  &amp;#40;&amp;#91;s&amp;#93; &amp;#40;gen-seq s 1&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;s t&amp;#93; &amp;#40;cond
           &amp;#40;empty? s&amp;#41; nil
           &amp;#40;= &amp;#40;count s&amp;#41; t&amp;#41; &amp;#40;cons s &amp;#40;lazy-seq &amp;#40;gen-seq &amp;#40;rest s&amp;#41; 1&amp;#41;&amp;#41;&amp;#41;
           :else &amp;#40;cons &amp;#40;take t s&amp;#41; &amp;#40;lazy-seq &amp;#40;gen-seq s &amp;#40;inc t&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; Which generates the following:&lt;pre&gt;&lt;code&gt;&amp;#40;gen-seq '&amp;#40;5 2 3&amp;#41;&amp;#41; ;;; &amp;#40;&amp;#40;5&amp;#41; &amp;#40;5 2&amp;#41; &amp;#40;5 2 3&amp;#41; &amp;#40;2&amp;#41; &amp;#40;2 3&amp;#41; &amp;#40;3&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;So good so far.  After adding the length and ascending filter we have...&lt;pre&gt;&lt;code&gt;&amp;#40;fn &amp;#91;x&amp;#93;
   &amp;#40; -&amp;gt;&amp;gt; &amp;#40;&amp;#40;fn gen-seq
           &amp;#40;&amp;#91;s&amp;#93; &amp;#40;gen-seq s 1&amp;#41;&amp;#41;
           &amp;#40;&amp;#91;s t&amp;#93; &amp;#40;cond
                    &amp;#40;empty? s&amp;#41; nil
                    &amp;#40;= &amp;#40;count s&amp;#41; t&amp;#41; &amp;#40;cons s &amp;#40;lazy-seq &amp;#40;gen-seq &amp;#40;rest s&amp;#41; 1&amp;#41;&amp;#41;&amp;#41;
                    :else &amp;#40;cons &amp;#40;take t s&amp;#41; &amp;#40;lazy-seq &amp;#40;gen-seq s &amp;#40;inc t&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; x&amp;#41;
         &amp;#40;filter &amp;#40;fn &amp;#91;e&amp;#93; &amp;#40;&amp;gt; &amp;#40;count e&amp;#41; 1&amp;#41;&amp;#41;&amp;#41;
         &amp;#40;filter &amp;#40;fn &amp;#91;e&amp;#93; &amp;#40;apply &amp;lt; e&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;But the first hitch in my plan has appeared.  The sort natural order places all of the longest elements at the rear of the list, not the front.  Reversing the list causes the unit tests to fail since one of the requirements is grabbing the first of the longest sequences of equal length, not the last.&lt;/p&gt;&lt;p&gt;Take 2:  we have a list of sequences.  We can group-by instead of sorting on count, find the max key, and take the first element of the corresponding value. Structurally we add a let binding so we can manipulate the keys and the map after we build it.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;fn &amp;#91;x&amp;#93;
   &amp;#40;let &amp;#91;seq-map
         &amp;#40;-&amp;gt;&amp;gt; &amp;#40;&amp;#40;fn gen-seq
                 &amp;#40;&amp;#91;s&amp;#93; &amp;#40;gen-seq s 1&amp;#41;&amp;#41;
                 &amp;#40;&amp;#91;s t&amp;#93; &amp;#40;cond
                          &amp;#40;empty? s&amp;#41; nil
                          &amp;#40;= &amp;#40;count s&amp;#41; t&amp;#41; &amp;#40;cons s &amp;#40;lazy-seq &amp;#40;gen-seq &amp;#40;rest s&amp;#41; 1&amp;#41;&amp;#41;&amp;#41;
                          :else &amp;#40;cons &amp;#40;take t s&amp;#41; &amp;#40;lazy-seq &amp;#40;gen-seq s &amp;#40;inc t&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; x&amp;#41;
              &amp;#40;filter &amp;#40;fn &amp;#91;e&amp;#93; &amp;#40;&amp;gt; &amp;#40;count e&amp;#41; 1&amp;#41;&amp;#41;&amp;#41;
              &amp;#40;filter &amp;#40;fn &amp;#91;e&amp;#93; &amp;#40;apply &amp;lt; e&amp;#41;&amp;#41;&amp;#41;
              &amp;#40;group-by count&amp;#41;&amp;#41;
         m-key &amp;#40;apply max &amp;#40;keys seq-map&amp;#41;&amp;#41;&amp;#93;
     &amp;#40;first &amp;#40;seq-map m-key&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ah -- so close.  But now we are failing the unit test in which there is no ascending sequence at all.  This causes the max assignment to fail. But now we simply add a nil check and we are good to go.  The final result:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;fn &amp;#91;x&amp;#93;
   &amp;#40;let &amp;#91;seq-map
         &amp;#40;-&amp;gt;&amp;gt; &amp;#40;&amp;#40;fn gen-seq
                 &amp;#40;&amp;#91;s&amp;#93; &amp;#40;gen-seq s 1&amp;#41;&amp;#41;
                 &amp;#40;&amp;#91;s t&amp;#93; &amp;#40;cond
                          &amp;#40;empty? s&amp;#41; nil
                          &amp;#40;= &amp;#40;count s&amp;#41; t&amp;#41; &amp;#40;cons s &amp;#40;lazy-seq &amp;#40;gen-seq &amp;#40;rest s&amp;#41; 1&amp;#41;&amp;#41;&amp;#41;
                          :else &amp;#40;cons &amp;#40;take t s&amp;#41; &amp;#40;lazy-seq &amp;#40;gen-seq s &amp;#40;inc t&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; x&amp;#41;
              &amp;#40;filter &amp;#40;fn &amp;#91;e&amp;#93; &amp;#40;&amp;gt; &amp;#40;count e&amp;#41; 1&amp;#41;&amp;#41;&amp;#41;
              &amp;#40;filter &amp;#40;fn &amp;#91;e&amp;#93; &amp;#40;apply &amp;lt; e&amp;#41;&amp;#41;&amp;#41;
              &amp;#40;group-by count&amp;#41;&amp;#41;
         m-key &amp;#40;if &amp;#40;seq seq-map&amp;#41;
                 &amp;#40;apply max &amp;#40;keys seq-map&amp;#41;&amp;#41;
                 nil&amp;#41;&amp;#93;
     &amp;#40;vec &amp;#40;first &amp;#40;seq-map m-key&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;I think the result is pretty readable.
</description>
<pubDate>
Sun, 01 Mar 2015 00:00:00 -0500
</pubDate>
<author>
Eric Somdahl
</author>
</item>
<item>
<guid>
http://ericsomdahl.github.io/posts/2015-02-27-Cryogen-Workflow.html
</guid>
<link>
http://ericsomdahl.github.io/posts/2015-02-27-Cryogen-Workflow.html
</link>
<title>
Cryogen Workflow
</title>
<description>
&lt;h3&gt;&lt;a name=&quot;the&amp;#95;github&amp;#95;deployment&amp;#95;plot&amp;#95;thickens&quot;&gt;&lt;/a&gt;The github deployment plot thickens&lt;/h3&gt;In order to deploy my &lt;a href='http://cryogenweb.org'&gt;Cryogen&lt;/a&gt; blog onto github.io, I had created two different repos&lt;ul&gt;&lt;li&gt;My Cryogen project&lt;/li&gt;&lt;li&gt;the github.io generated pages&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;After running &lt;pre&gt;&lt;code&gt;lein ring server-headless 
 &lt;/code&gt;&lt;/pre&gt; in the cryogen project I would manually copy the generated files from the /resources/public/ folder to the root of the github.io repo.  I assumed I was missing something.&lt;/p&gt;&lt;p&gt;According to &lt;a href='http://tangrammer.github.io/posts/02-12-2014-cryogen-and-github.html'&gt;this page&lt;/a&gt;,  this is basically it.  Very meh.&lt;/p&gt;&lt;p&gt;Perhaps a Leiningen plugin is in order.&lt;/p&gt;
</description>
<pubDate>
Fri, 27 Feb 2015 00:00:00 -0500
</pubDate>
<author>
Eric Somdahl
</author>
</item>
<item>
<guid>
http://ericsomdahl.github.io/posts/2015-02-26-Setup.html
</guid>
<link>
http://ericsomdahl.github.io/posts/2015-02-26-Setup.html
</link>
<title>
Setup
</title>
<description>
&lt;h3&gt;&lt;a name=&quot;hi&amp;#95;there&quot;&gt;&lt;/a&gt;Hi There&lt;/h3&gt;&lt;p&gt;This is my first post to what I hope will be a vaguely useful blog.  If only for myself -- as a means of recording useful things I stumble across as I solve problems in either my work or my recreational software development.&lt;/p&gt;&lt;p&gt;I may also post about motorcycles.  Or judo. I like to learn about those things as well.&lt;/p&gt;&lt;p&gt;I think my first task will be to do something to automate this posting workflow. I am currently learning &lt;a href='http://clojure.org'&gt;Clojure&lt;/a&gt; and in an effort to eat some of my own dogfood I am using &lt;a href='http://cryogenweb.org'&gt;Cryogen&lt;/a&gt; to generate this site.  Surely there is some way to get &lt;a href='http://leiningen.org'&gt;Leiningen&lt;/a&gt; to push this to Github for me...&lt;/p&gt;
</description>
<pubDate>
Thu, 26 Feb 2015 00:00:00 -0500
</pubDate>
<author>
Eric Somdahl
</author>
</item>
</channel>
</rss>
